# Prototype Pollution Vulnerability Report

## Vulnerability Classification
**TRUE POSITIVE - High Severity**

## Location
- **File**: `src/lib/api-helpers.ts`
- **Lines**: 100-108
- **Function**: `sanitizeInput()`

## Vulnerability Details

### Root Cause
The `sanitizeInput` function recursively processes objects using `Object.entries()` and bracket notation assignment without checking for dangerous keys like `__proto__`, `constructor`, or `prototype`.

```typescript
if (value && typeof value === 'object') {
  const sanitized: Record<string, unknown> = {};
  for (const [key, val] of Object.entries(value)) {
    sanitized[key] = sanitizeInput(val);  // ← Vulnerable line
  }
  return sanitized;
}
```

### Attack Mechanism

1. **Input Processing**: When processing JSON input like:
   ```json
   {
     "name": "test",
     "__proto__": {
       "is_public": true,
       "is_editable": false
     }
   }
   ```

2. **Object.entries() Behavior**: `Object.entries()` returns `__proto__` as a regular key when it's created via `JSON.parse()`.

3. **Bracket Notation Assignment**: The line `sanitized[key] = sanitizeInput(val)` with `key = "__proto__"` modifies the object's prototype chain.

4. **Prototype Chain Pollution**: While this doesn't pollute the global `Object.prototype`, it pollutes the **specific object's prototype chain**.

5. **Zod Validation Bypass**: Zod's validation uses the `in` operator which checks the prototype chain:
   ```javascript
   if ('is_public' in maliciousSanitized) {
     // Returns TRUE because is_public is in the prototype chain
     // Zod extracts it even though it's not an own property
   }
   ```

6. **Value Injection**: The injected values override schema defaults and are extracted during destructuring.

## Proof of Concept

### Attack Request
```http
POST /api/admin/master-data
Content-Type: application/json

{
  "name": "test_setting",
  "category": "system",
  "value": "normal_value",
  "__proto__": {
    "is_public": true,
    "is_editable": false,
    "clinic_id": "00000000-0000-0000-0000-000000000000"
  }
}
```

### Expected Behavior
- `is_public`: false (schema default)
- `is_editable`: true (schema default)
- `clinic_id`: null or user's clinic

### Actual Behavior (Vulnerable)
- `is_public`: **true** (attacker-controlled)
- `is_editable`: **false** (attacker-controlled)
- `clinic_id`: **"00000000-0000-0000-0000-000000000000"** (attacker-controlled)

## Impact Assessment

### Severity: HIGH (7-8/10)

### Attack Scenarios

1. **Data Exposure** (Privacy Violation):
   - Attacker sets `is_public: true` on private medical records
   - Sensitive patient data becomes publicly accessible
   - Violates HIPAA/medical privacy regulations

2. **Access Control Bypass** (Authorization Violation):
   - Attacker sets `clinic_id` to another clinic's ID
   - Bypass multi-tenant isolation
   - Access/modify data from other medical facilities

3. **Data Integrity** (Audit Trail Manipulation):
   - Attacker sets `is_editable: false` to lock critical settings
   - Sets `updated_by` to a different user's UUID
   - Falsifies audit trails

4. **Privilege Escalation**:
   - Inject fields that affect authorization logic
   - Bypass role-based access controls

## Affected Code Paths

All API routes that use `processApiRequest()` with `sanitizeInputValues: true` (default):

1. `/api/admin/master-data` (POST, PUT, PATCH, DELETE)
2. `/api/admin/tables` (POST, PUT, PATCH, DELETE)
3. `/api/admin/dashboard` (potentially)
4. Any future endpoints using `sanitizeInput()`

## Why This is NOT a False Positive

### Hard Exclusion Rules Check:
1. ✗ Not environment variables or CLI flags - this is user HTTP input
2. ✗ Not React component rendering - this is server-side API
3. ✗ Not client-side validation - this is server-side processing
4. ✗ Not theoretical - demonstrated working exploit
5. ✗ Not memory safety in safe language - this is logic vulnerability
6. ✗ Not test-only code - production API code
7. ✗ Not documentation - actual code vulnerability
8. ✗ Not AI prompt injection - real prototype pollution
9. ✗ Not regex DOS - object manipulation vulnerability
10. ✗ Not lack of hardening - exploitable vulnerability

### Defense Layer Analysis:

**Layer 1: sanitizeInput()** - ✗ BYPASSED
- Allows `__proto__` to pollute object prototype chain

**Layer 2: Zod Validation** - ✗ BYPASSED
- Uses `in` operator which checks prototype chain
- Extracts injected properties as valid data

**Layer 3: Destructuring** - ✗ BYPASSED
- Extracts polluted values from Zod result

**Layer 4: Database Insertion** - ✗ BYPASSED
- Polluted values inserted into database

## Confidence Score: 9/10

### Why 9/10 and not 10/10:
- Actual exploitation depends on specific schema definitions
- Some schemas may not have exploitable optional fields
- Production environment details not fully verified

### Why NOT a False Positive:
- Demonstrated working exploit with real Zod library
- Confirmed prototype chain pollution occurs
- Zod validation does NOT prevent the attack
- Values successfully injected into validation output
- Direct security impact (authorization bypass, data exposure)

## Recommendations

### Immediate Fix (Required):

```typescript
// Option 1: Blacklist dangerous keys
const DANGEROUS_KEYS = ['__proto__', 'constructor', 'prototype'];

export function sanitizeInput(value: unknown): unknown {
  if (typeof value === 'string') {
    return DOMPurify.sanitize(value);
  }

  if (Array.isArray(value)) {
    return value.map(sanitizeInput);
  }

  if (value && typeof value === 'object') {
    const sanitized: Record<string, unknown> = {};
    for (const [key, val] of Object.entries(value)) {
      // Skip dangerous keys
      if (DANGEROUS_KEYS.includes(key)) {
        continue;
      }
      sanitized[key] = sanitizeInput(val);
    }
    return sanitized;
  }

  return value;
}

// Option 2: Use Object.create(null) for prototype-less objects
export function sanitizeInput(value: unknown): unknown {
  if (typeof value === 'string') {
    return DOMPurify.sanitize(value);
  }

  if (Array.isArray(value)) {
    return value.map(sanitizeInput);
  }

  if (value && typeof value === 'object') {
    const sanitized = Object.create(null); // No prototype!
    for (const [key, val] of Object.entries(value)) {
      sanitized[key] = sanitizeInput(val);
    }
    return sanitized;
  }

  return value;
}
```

### Additional Hardening:

1. **Use Zod Strict Mode** (partial mitigation):
   ```typescript
   const masterDataSchema = z.object({...}).strict();
   ```
   Note: This helps but may not fully prevent the attack.

2. **Use Object.hasOwnProperty() checks**:
   ```typescript
   for (const [key, val] of Object.entries(value)) {
     if (!Object.prototype.hasOwnProperty.call(value, key)) {
       continue; // Skip inherited properties
     }
     sanitized[key] = sanitizeInput(val);
   }
   ```

3. **Use a proper sanitization library**:
   Consider using `secure-json-parse` or similar libraries that handle prototype pollution.

## Test Cases

```javascript
// Test 1: Block __proto__
const input1 = JSON.parse('{"name":"test","__proto__":{"evil":true}}');
const result1 = sanitizeInput(input1);
console.assert(!('evil' in result1), 'Should block __proto__');

// Test 2: Block constructor
const input2 = JSON.parse('{"name":"test","constructor":{"prototype":{"evil":true}}}');
const result2 = sanitizeInput(input2);
console.assert(!('evil' in result2), 'Should block constructor.prototype');

// Test 3: Allow normal nested objects
const input3 = {"name":"test","settings":{"theme":"dark"}};
const result3 = sanitizeInput(input3);
console.assert(result3.settings.theme === 'dark', 'Should allow normal nested objects');
```

## References

- [CWE-1321: Improperly Controlled Modification of Object Prototype Attributes](https://cwe.mitre.org/data/definitions/1321.html)
- [OWASP: Prototype Pollution](https://owasp.org/www-community/vulnerabilities/Prototype_Pollution)
- [Snyk: Prototype Pollution Attack](https://snyk.io/blog/prototype-pollution-attack/)

## Timeline

- **Discovery**: 2025-10-24
- **Verification**: 2025-10-24
- **Status**: CONFIRMED - Awaiting Fix
